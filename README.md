**Мой первый сайт книжного магазина, этот проект я делал по книге и чучуть его изменил**
- Python 3.10
- Django==4.0.6
*Установка*
- pip install requirements.txt
# Глава первая Docker
- установка docker
# Глава вторая PostgresSQL
- установка базы данных
# Глава третья проект  
- установка проекта 
- в настройках меняем базу на PostgresSQL
- создаем пользовательскую модель custom user model
- обновляем настройки для пользовательской модели
- настройка UserCreationForm и UserChangeForm
- добавление custom user model в admin.py
# Глава четвертая приложение
- создаем приложение pages
- настраиваем TEMPLATES для поиска в одной папке
- создаем базовый шаблон _base и наследуемся от него
- создаем URLS и прописываем url в нем
- создаем в VIES классы представления
# Глава пятая регистрация пользователя 
- используем приложение auth добавляем в базовый URLS его путь
- посмотреть какие url входят во встроенное приложение auth можно по ссылке https://github.com/django/django/blob/b9cf764be62e77b4777b3a75ec256f6209a57671/django/contrib/auth/urls.py
- добавили настройку LOGIN_REDIRECT_URL и LOGOUT_REDIRECT_URL для перенаправления пользователя
- переопределили login.html создав свой 
- не забывай устанавливать в формы СSRF защиту ({% csrf_token %})
- *регистрацию пользователя мы создаем сами*
- создали в приложении USERS urls 
- создали во VIEWS класс для регистрации
- создали шаблон 
# Глава шестая статические активы
- указали в настройке STATICFILES_DIRS где будут располагаться статические данные
- STATIC_ROOT настройка статических файлов для производства, поэтому для него должно быть установлено другое имя, обычно staticfiles
- указали явно настройку поиска статических данных STATICFILES_FINDERS
- создали папу static 
- подключили к шаблонам статику
- в шаблонах JavaScript должен подключатся последним, после HTML и CSS это ускоряет страницу
- запустили команду python manage.py collectstatic, чтобы создать единый, готовый к работе каталог со всеми статическими файлами
- подключили Bootstrap 
- установили Django Crispy Forms для подключения стилей к форме 
# Глава седьмая расширенная регистрация пользователей
- установили django-allauth
- указали в настройках SITE_ID = 1
- в настройке AUTHENTICATION_BACKENDS указали на использования входа через эмаэл 
- в настройке EMAIL_BACKEND указали что бы любые электронные письма в консоль командной строки
- ACCOUNT_LOGOUT_REDIRECT переопределяет настройку LOGOUT_REDIRECT_URL настрой перенаправления страницы после выхода
- мы убираем в URLS путь auth и приписываем URL django allauth
- так же удаляем URL users
- удаляем в users urls.py и views.py
- так как django-allauth ищет шаблоны templates/account то мы создаем директорию и переносим наши шаблоны
- ACCOUNT_SESSION_REMEMBER настройка для сохранения сессий пользователя, мы установили True
- ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE при регистрации один раз просит пароль если значение False
- ACCOUNT_USERNAME_REQUIRED указали Fasle имя пользователя не обязательно
- ACCOUNT_AUTHENTICATION_METHOD указали значение 'email' при входе использовать эмаил 
- ACCOUNT_EMAIL_REQUIRED указали значение True эмаеил пользователя  обязательно
- ACCOUNT_UNIQUE_EMAIL указали значение True эмеил должен быть уникальным 
- я добавил социальную аутентификацию ссылка https://wsvincent.com/django-allauth-tutorial/
# Глава восьмая переменные среды
- для переменной среды использовали django-environ ссылка: https://github.com/joke2k/django-environ
# Глава девятая email
- переопределили файлы email_confirmation_subject.txt и email_confirmation_message.txt во создав их у себя в templates/account/email
- DEFAULT_FROM_EMAIL настройка для эмейла по умолчанию
- по книге вывод писем был только в консоли, исправим это
- Настроил Goodle SMTP
- Прописал в настройках джанго константы для отправки почты 
- использовал send_mail во views для отправки писем 

# Глава десятая приложение Books
- создали приложение books
- спланировали и создали модель и базу данных
- зарегистрировали в админке 
- создали пайтон фал URLS
- создали папку books для шаблонов
- во vies в классах всегда явно передавай значения словарей через аргументы класса context_object_name
- в моделях добавили метод get_absolute_url используй в шаблонах этот метод 
- лучший подход не использовать слаг или pk а использовать UUID
- мы импортировали в модель uuid
- id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
- как видно выше мы изменили id и добавили uuid4 для шифрования
- также в URLS поменяли путь '<uuid:pk>'
# Глава одиннадцатая приложение Reviews
- в модели создали класс для комментариев (review)
- зарегистрировали его в админке
- обновили шаблон для отображения коментариев 
# Глава двенадцатая работа с файлами/загрузки изображения
- для работы с изображением установим install pillow
- добавили MEDIA_ROOT - абсолютный путь файловой системы к каталогу
- добавили MEDIA_URL - URL, который мы можем использовать в наших шаблонах для файлов
- создали папку для файлов с названием media
- в главном URLS мы добавили настройку + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 
- добавили поле в модель БД для хранения изображения 
- изменили шаблон для отображения изображения
# Глава триннадцатая Разрешения
- в классах Vies импортировали LoginRequiredMixin
- наследуем миксин первым, где нужна проверка зарегистрирован ли пользователь
- в классах указываем login_url - куда перенаправлять если не зарегистрирован 
- мы в классе модели Book добавили в Меta сласс настройку permissions 
- провили миграцию и применили ее 
- в VIES мы импортировали PermissionRequiredMixin - проверка пользователя на права доступа
- наследовали этот микин после LoginRequiredMixin
-  permission_required - добавили аргумент для указания какое разрешение должно быть 

# Глава Четырннадцатая (Не знаю как реализовать)

# Глава Петнадцатая Поиск
- содали в books/url путь на контролер 
- создали контроллер в контролере для логики поиска ипользовали Q
- POST - Любой запрос, который изменяет состояние базы данных (создает, редактирует или удаляет данные) должен использовать POST
- GET - следует использовать только для запросов, которые не влияют на состояние приложения, таких как поиск, когда ничего в базе данных не меняется
- В html создали форм для поиска 
# Глава Шестнадцатая оптимизация 
- подключили debug-toolbar
- подключили кеширование (оно глюковатое)
- рассказал автор про индексы
- рассказал про оптимизацию внешних ресурсов (JavaScript, ижображение и так далее)



# Добавил встроенное приложение для создания статических страниц
- в настройках проэкта должны зарегистрированные быть 2 проэкта  'django.contrid.flatpages', 'django.contrib.sites'
- в настройка в миделвеа добовляем 'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware'
- в настройках устанавливаем SITE_ID = 1
- в главном файле URLS добавляем path('pages/', include('django.contrib.flatpages.urls')),
- проводим миграцию и применяем ее  




# Добавил пагинацию 
- использовал для пагинации paginate_by который поставляется вместе с ListView
- в шаблонах page_range - итератор формирующий страницы
- в шаблонах paginator - обьект пагинатора (ссылка на класс пагинатора)
- в шаблонах page_obj - cписок обьектов для текущей страници
- в шаблоне прописсал пагинацию для перехода по страницам и пометил html код в блок block pagination
- на странице поиска тоже добал пагинацию, но что бы при переходе между страниц URL помнил элемент поиска добавл в класс поиска значение которое мы ищем через метод get_context_data
- в шаблоне траницы поиска я переопределил блок block pagination добавив туда переменную Q пример: <a class="prev" href="?page={{ p }}&queryset ={{ query }}">{{ p }}</a>

# Пагинация в контроллере фильтра 
- использовал библиотеку django-spurl
- ссылка на библиотеку https://github.com/j4mie/django-spurl
- в html загрузил тег {% load spurl %}
- в html добавил строку для пагинации <a class="page-link" href="{% spurl query=request.GET set_query='page={{ p }}'%}">{{ p }}</a>


# Добавил капчу 
- изменил страницу About Page на Feedback
- создал класс ContactFormView и наследовал его FormView
- FormView - класс формы не взаимодейсвующий с базой данных
- создал forms 
- в forms создал класс формы 
- импортировалл pip install  django-simple-captcha
- подключил приложение и указал его в главном URL
- провел миграцию 
- в forms ипортировал капчу и подключил ее 
- сылка на доку капчи https://django-simple-captcha.readthedocs.io/en/latest/usage.html




**В этотм проэкте я**
- Использовал UUID заместь слагов(автор говорит это лучшая практика)
- Добаввил социальнную аторизацию 
- Использовал Мисины для ауторизации и проверки пользователей
- В модели Book в мета классе добавил разрешентя для пользователей через permissions 
- В первые прочитал про "Переменные среды" я знаю что их нельзя выкладывать на гитхаб
- Не закончен сброс пароля 
*Глава 14 "Stripe"*
- Описывается дключение к Stripe для платежей
- эту главу я не реализовал так как не смог зарегистрироваться в Stripe
*Глава 15 "Поиск"*
- icontains является нечувствительным к регистру и его использоваля для поиска
- Для поиска импортировали Q 
- Любой запрос, который изменяет состояние базы данных - создает, редактирует или удаляет данные - должен использовать POST
- GET объединяет данные в строку, которая добавляется к целевому URL. GET следует использовать только для запросов, которые не влияют на состояние приложения, таких как поиск
*Глава 16 "Производительность"*
- установили debug-toolbar
- подключили кеш 
- проиндексировали id 
- говорилось про оптимизацию фронтеда